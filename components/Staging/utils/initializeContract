import { useContractStore as ContractStore } from "@/hooks/store/contractStore";
import { useWalletStore } from "@/hooks/store/walletStore";
import { Interface, Contract, Log, Result, Wallet, InterfaceAbi } from "ethers";
import { useToast } from "@/hooks/use-toast";

interface DeployData {
  [key: string]: unknown;
}

export const deployProxyContract = async (
  data: DeployData,
): Promise<Result[] | Error> => {
  const { SELECTED_CONTRACT, set_INITIALIZED_CONTRACT } = ContractStore();
  const { private_key, providers } = useWalletStore();
  const { toast } = useToast();

  if (!providers || !private_key) {
    throw new Error("providers or wallet not available");
  }

  let network_index = 0;
  switch (SELECTED_CONTRACT?.network) {
    case "Mainnet":
      network_index = 0;
      break;
    case "Optimism":
      network_index = 1;
      break;
    case "Arbitrum":
      network_index = 2;
      break;
  }

  const wallet = new Wallet(private_key, providers[network_index]);

  const master_address = SELECTED_CONTRACT?.master_address;
  const proxy_abi = SELECTED_CONTRACT?.abi;
  const master_abi = SELECTED_CONTRACT?.master_abi as InterfaceAbi;
  const function_name = SELECTED_CONTRACT?.function_name;
  const event_name = SELECTED_CONTRACT?.event_name;

  if (
    !master_address ||
    !proxy_abi ||
    !master_abi ||
    !function_name ||
    !event_name
  ) {
    throw new Error("Missing contract configuration");
  }

  const master_contract = new Contract(master_address, master_abi, wallet);

  console.log("checkpoint, calling deploy proxy function on blockchain");

  const iface = new Interface(master_abi);

  const deployFunction = iface.getFunction(function_name);
  if (!deployFunction) {
    throw new Error("Function not found in abi");
  }

  console.log(data);
  console.log(deployFunction);

  try {
    const tx = await master_contract[deployFunction.format()](
      ...Object.values(data),
    );
    const receipt = await tx.wait();

    let returnArgs: Result[] = [];
    let proxy_address = "";

    receipt.logs.forEach((log: Log) => {
      try {
        const parsed = iface.parseLog({
          topics: log.topics as string[],
          data: log.data,
        });

        if (parsed && parsed.name === event_name) {
          proxy_address = parsed.args[0] as string;
          returnArgs = [...parsed.args];
        } else {
          proxy_address = "error";
        }
      } catch (error) {
        console.log("Error parsing log:", error);
      }
    });

    const proxy_contract = new Contract(
      proxy_address,
      proxy_abi as InterfaceAbi,
      wallet,
    );
    set_INITIALIZED_CONTRACT(proxy_contract);

    return returnArgs;
  } catch (error) {
    const typedError = error as Error & { code?: string };
    if (typedError.code === "INSUFFICIENT_FUNDS") {
      toast({
        title: "PROXY DEPLOYMENT ERROR",
        description: "Insufficient Funds.",
        variant: "destructive",
      });
    }
    console.log(error);
    return typedError;
  }
};

export const connectProxyContract = async (
  address: string,
): Promise<Contract | Error> => {
  const { SELECTED_CONTRACT, set_INITIALIZED_CONTRACT } = ContractStore();
  const { private_key, providers } = useWalletStore();
  console.log(address);

  if (!SELECTED_CONTRACT || !private_key || !providers) {
    return new Error("Missing required configuration");
  }

  let network_index = 0;
  switch (SELECTED_CONTRACT.network) {
    case "Mainnet":
      network_index = 0;
      break;
    case "Optimism":
      network_index = 1;
      break;
    case "Arbitrum":
      network_index = 2;
      break;
    default:
      return new Error("Invalid network");
  }

  try {
    const wallet = new Wallet(private_key, providers[network_index]);

    if (!SELECTED_CONTRACT.master_address || !SELECTED_CONTRACT.master_abi) {
      return new Error("Missing master contract configuration");
    }

    const master_contract = new Contract(
      SELECTED_CONTRACT.master_address,
      SELECTED_CONTRACT.master_abi as InterfaceAbi,
      wallet,
    );

    // Add verification that mapping exists
    if (!SELECTED_CONTRACT.mapping_name) {
      return new Error("Mapping function name not specified");
    }

    try {
      const result =
        await master_contract[SELECTED_CONTRACT.mapping_name](address);

      if (result === wallet.address) {
        if (!SELECTED_CONTRACT.abi) {
          return new Error("Missing proxy contract ABI");
        }

        const proxy_contract = new Contract(
          address,
          SELECTED_CONTRACT.abi as InterfaceAbi,
          wallet,
        );
        set_INITIALIZED_CONTRACT(proxy_contract);
        return proxy_contract;
      } else {
        return new Error(
          "Contract not owned by this address, interaction prohibited",
        );
      }
    } catch (error) {
      const typedError = error as Error & { code?: string };
      if (typedError.code === "BAD_DATA") {
        return new Error("Contract not found in mapping");
      }
      return typedError;
    }
  } catch (error) {
    console.log("Error connecting proxy contract:", error);
    return error as Error;
  }
};
