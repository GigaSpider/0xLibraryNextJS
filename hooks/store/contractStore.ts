import { create } from "zustand";
import { Contract, TransactionReceipt } from "ethers";
import XMR_ETH from "./contractdata/XMR_ETH.json";
import ETH_XMR from "./contractdata/ETH_XMR.json";
import WAGER from "./contractdata/WAGER.json";
import MASTER from "./contractdata/MASTER.json";
import ETHZK from "./contractdata/ETHZK.json";

export enum NetworkIndex {
  "Mainnet" = 0,
  "Optimism" = 1,
  "Arbitrum" = 2,
  "Sepolia" = 3,
}

export type SmartContract = {
  id: number;
  name: string;
  address: string;
  engineer: string;
  chainId: number;
  proxy: boolean;
  abi: any;
  bytecode: string;
  fee: number;
  instructions: string;
  description: string;
  master_address?: string;
  master_abi?: any;
  function_name?: string;
  event_name?: string;
  mapping_name?: string;
};

const ethxmr: SmartContract = {
  id: 1,
  name: "Cross chain ETH/XMR Swap",
  address: "0x32c615C98E173d8e0D3cc98ee93fBD1734552449",
  engineer: "Admin",
  chainId: 10,
  proxy: true,
  abi: ETH_XMR.abi,
  bytecode: ETH_XMR.bytecode,
  fee: 0.5,
  description: `This contract enables signers to anonymously interact with a decentralized network of oracle servers which both send and receive monero, for full transparency, the exchange rates for monero and ethereum are calcuated on chain using chainlink pricefeed oracles.You may trade any amount as long as it is above the threshold of 0.001ETH. Due to funding limitations, this contract can't support unlimited quantities to be exchanged. If the oracle server cannot fulfil your request due to insufficient funds. The trade will be cancelled automatically and your funds will be returned.


    In order to protect user anonymity and security. This contract requires participants to submit to an assymetic encryption protocol in order to hide the monero addresses from the public blockchain`,
  instructions:
    "Instructions on usage: To ensure user anonymity and security. This contract uses ",
  master_address: "0x1f2272A0D42A6C34805908B9D28253a9C293ef3C",
  master_abi: MASTER.abi,
  function_name: "CreateEthXmrContract",
  event_name: "EthXmrContractCreation",
  mapping_name: "ETH_XMR_CONTRACTS",
};

const xmreth: SmartContract = {
  id: 2,
  name: "Cross chain XMR/ETH Swap",
  address: "0x715EE67c54BBa24A05f256aeDB4f6bb0AD2E06F3",
  engineer: "Admin",
  chainId: 10,
  proxy: true,
  abi: XMR_ETH.abi,
  bytecode: XMR_ETH.bytecode,
  fee: 0.5,
  description: "Contract description",
  instructions: "Instructions on usage: ",
  master_address: "0xE56eFe07c2a6cd7C4d41B441c3DFeb5cbc7087eF",
  master_abi: MASTER.abi,
  function_name: "CreateXmrEthContract",
  event_name: "XmrEthContractCreation",
  mapping_name: "XMR_ETH_CONTRACTS",
};

const zksnark_01: SmartContract = {
  id: 3,
  name: "Zero Knowledge Obfuscation Deposit/Withdraw | Denomination: 0.01 ETH",
  address: "0xDE03E825d944e2Fce71761faE63e1F7719f1F632",
  engineer: "Admin",
  chainId: 11155111,
  proxy: false,
  abi: ETHZK.abi,
  bytecode: ETHZK.bytecode,
  fee: 0.1,
  description:
    "This contract utilizes advanced eliptical curve cryptography as part of a complex mathematical process which essentially proves the right of ownership to a depositor's funds from another address without revealing who the owner of the deposit actually is, where by at the end of the process there is no connection between the depositor and the withdrawers wallets. By pooling many users deposits in a large merkle tree where each deposit is a fixed uniform amount, and by initiating withdrawals using zero knowledge proofs, it is technically impossible to discern who among the withdrawers is associated with which deposit, and so the identity of withdrawn funds becomes obfuscated",
  instructions: `Instructions on usage: You will need to use the Encryption Tools menu located on the bottom left of your screen to interact with this contract. Also you will need to use Wallet Actions in the upper left corner to create or load a seperate wallet from the one which you make your deposit from while you are withdrawing. In other words you need to use two seperate wallets in order to effectively use this contract where neither wallet has ever transacted with the other before. Our custom built multi-wallet tool is powerful and designed to help you easily manage multiple wallets and private keys, all data is stored locally in your browser and is never shared with any backend server or api endpoint.

  Step 1: GENERATE SECRETS
  To get started click on the Encryption Tools button and select the ZK Keygen tool from the list of tools. Click on generate secrets, and then download them and keep the file secure to make sure that you can't lose your deposit.

  Step 2: DEPOSIT ETHEREUM
 Copy the public commitment generated by the ZK Keygen tool and paste it into the deposit function of this contract. Set the deposit amount to the denomination of the contract (0.01, 0.05, 0.1, or 1ETH) and simply deposit your funds.

  Step 2: WAIT
  Now that you have deposited your ethereum into the contract, you should wait an appropriate amount of time before initiating your withdrawal. I recommend waiting between 30 minutes and 24 hours before initializing your withdrawal.

  Step 3: GENERATE PROOF
  Copy the private proving key generated by the ZK Keygen tool and paste it into the ZK Prover tool along with the address of the contract which you deposited to. Click on generate proof. This may take a few seconds or up to a minute because the proving algorithm is computationally intensive.

  Step 4 (No withdrawal agent): WITHDRAW ETHEREUM
  Using a different wallet, copy the proof generated by the ZK proving tool and paste it directly into the withdraw function on the zk contract in the dashboard. Go ahead and withdraw it, you will recieve confirmation of the withdrawal in the Performance window.

  Step 4 (Using the withdrawal agent):
  `,
};

const zksnark_05: SmartContract = {
  id: 4,
  name: "Zero Knowledge Obfuscation Deposit/Withdraw | Denomination: 0.05 ETH",
  address: "0xB7990562f05c9a5D6ee0D5F7c2ff90d20644cf4c",
  engineer: "Admin",
  chainId: 11155111,
  proxy: false,
  abi: ETHZK.abi,
  bytecode: ETHZK.bytecode,
  fee: 0.1,
  description:
    "This contract uses advanced elipitcal curve cryptography in order to prove ownership of a depositor's ethereum without revealing who the owner of the deposit is to anyone who may be auditing the ethereum blockchain. By sending a fixed uniform deposit amount, it is impossible to discern one user of the contract from another, and so the idenity of your funds becomes anonymized",
  instructions: `Instructions on usage: You will need to use the Encryption Tools menu located on the bottom left of your screen.

  Step 1: To get started click on encryption tools and select the ZK Keygen tool from the list of tools. You will use this tool in order to create both public and secret random numbers locally in your browser which aren't shared with any backend system. You can verify this by examining our open source repository for 0xLibrary. Click the Generate Secrets button to create your public commitment and private proving key. The commitment will be used to identify your deposit and the proving key will be used later in the process of generating your zero knowledge proof which gives you and only you access to your deposited funds later on

  Step 2: Copy the public commitment generated by the ZK Keygen tool and paste it into the deposit function of this zero knowledege obfuscation contract. Specify the amount of ethereum that you are sending with the deposit and set it to the denomination of the obfuscation contract. Don't worry, if you accidentally send the wrong amount the transaction will revert and you will see an error message.

  Step 2: Now that you have deposited your ethereum into the contract, you should wait an appropriate amount of time before initiating your withdrawal. I recommend waiting between 30 minutes and 24 hours in order to get the most effect. The more time that you wait the harder it is to draw a connection between the account you deposit from the account you withdraw from.

  Step 3: Copy the private proving key generated by the ZK Keygen tool and paste it into the ZK Prover tool along with the address of the contract which you deposited to. Click on generate proof and wait for your system to finish computing the proof. This may take a few seconds or up to a minute because your system needs to download a 20MB zero knowledge proving circuit and run some computationally intense calculations.

  Step 4 (No withdrawal agent): Using a different wallet, copy the proof generated by the ZK proving tool and paste it directly into the withdraw function on the zk contract in the dashboard. Go ahead and withdraw it, you will recieve confirmation of the withdrawal in the Performance window.

  Step 4 (Using the withdrawal agent)
  `,
};

const zksnark_1: SmartContract = {
  id: 5,
  name: "Zero Knowledge Obfuscation Deposit/Withdraw | Denomination: 0.1 ETH",
  address: "0x52346736Ae0279f4219313AAE626F12bCc7DAFA3",
  engineer: "Admin",
  chainId: 11155111,
  proxy: false,
  abi: ETHZK.abi,
  bytecode: ETHZK.bytecode,
  fee: 0.1,
  description:
    "This contract uses advanced elipitcal curve cryptography in order to prove ownership of a depositor's ethereum without revealing who the owner of the deposit is to anyone who may be auditing the ethereum blockchain. By sending a fixed uniform deposit amount, it is impossible to discern one user of the contract from another, and so the idenity of your funds becomes anonymized",
  instructions: `Instructions on usage: You will need to use the Encryption Tools menu located on the bottom left of your screen.

  Step 1: To get started click on encryption tools and select the ZK Keygen tool from the list of tools. You will use this tool in order to create both public and secret random numbers locally in your browser which aren't shared with any backend system. You can verify this by examining our open source repository for 0xLibrary. Click the Generate Secrets button to create your public commitment and private proving key. The commitment will be used to identify your deposit and the proving key will be used later in the process of generating your zero knowledge proof which gives you and only you access to your deposited funds later on

  Step 2: Copy the public commitment generated by the ZK Keygen tool and paste it into the deposit function of this zero knowledege obfuscation contract. Specify the amount of ethereum that you are sending with the deposit and set it to the denomination of the obfuscation contract. Don't worry, if you accidentally send the wrong amount the transaction will revert and you will see an error message.

  Step 2: Now that you have deposited your ethereum into the contract, you should wait an appropriate amount of time before initiating your withdrawal. I recommend waiting between 30 minutes and 24 hours in order to get the most effect. The more time that you wait the harder it is to draw a connection between the account you deposit from the account you withdraw from.

  Step 3: Copy the private proving key generated by the ZK Keygen tool and paste it into the ZK Prover tool along with the address of the contract which you deposited to. Click on generate proof and wait for your system to finish computing the proof. This may take a few seconds or up to a minute because your system needs to download a 20MB zero knowledge proving circuit and run some computationally intense calculations.

  Step 4 (No withdrawal agent): Using a different wallet, copy the proof generated by the ZK proving tool and paste it directly into the withdraw function on the zk contract in the dashboard. Go ahead and withdraw it, you will recieve confirmation of the withdrawal in the Performance window.

  Step 4 (Using the withdrawal agent)
  `,
};

const zksnark1_0: SmartContract = {
  id: 6,
  name: "Zero Knowledge Obfuscation Deposit/Withdraw | Denomination: 1.0 ETH",
  address: "0xFA8B3633C15b8a046E6060402a1A147da91fa92c",
  engineer: "Admin",
  chainId: 11155111,
  proxy: false,
  abi: ETHZK.abi,
  bytecode: ETHZK.bytecode,
  fee: 0.1,
  description:
    "This contract uses advanced elipitcal curve cryptography in order to prove ownership of a depositor's ethereum without revealing who the owner of the deposit is to anyone who may be auditing the ethereum blockchain. By sending a fixed uniform deposit amount, it is impossible to discern one user of the contract from another, and so the idenity of your funds becomes anonymized",
  instructions: `Instructions on usage: You will need to use the Encryption Tools menu located on the bottom left of your screen.

  Step 1: To get started click on encryption tools and select the ZK Keygen tool from the list of tools. You will use this tool in order to create both public and secret random numbers locally in your browser which aren't shared with any backend system. You can verify this by examining our open source repository for 0xLibrary. Click the Generate Secrets button to create your public commitment and private proving key. The commitment will be used to identify your deposit and the proving key will be used later in the process of generating your zero knowledge proof which gives you and only you access to your deposited funds later on

  Step 2: Copy the public commitment generated by the ZK Keygen tool and paste it into the deposit function of this zero knowledege obfuscation contract. Specify the amount of ethereum that you are sending with the deposit and set it to the denomination of the obfuscation contract. Don't worry, if you accidentally send the wrong amount the transaction will revert and you will see an error message.

  Step 2: Now that you have deposited your ethereum into the contract, you should wait an appropriate amount of time before initiating your withdrawal. I recommend waiting between 30 minutes and 24 hours in order to get the most effect. The more time that you wait the harder it is to draw a connection between the account you deposit from the account you withdraw from.

  Step 3: Copy the private proving key generated by the ZK Keygen tool and paste it into the ZK Prover tool along with the address of the contract which you deposited to. Click on generate proof and wait for your system to finish computing the proof. This may take a few seconds or up to a minute because your system needs to download a 20MB zero knowledge proving circuit and run some computationally intense calculations.

  Step 4 (No withdrawal agent): Using a different wallet, copy the proof generated by the ZK proving tool and paste it directly into the withdraw function on the zk contract in the dashboard. Go ahead and withdraw it, you will recieve confirmation of the withdrawal in the Performance window.

  Step 4 (Using the withdrawal agent)
  `,
};

const gambler: SmartContract = {
  id: 7,
  name: "Variable Probability Coinflip",
  address: "0xE1B78225971d5c8957C749Dd18e56dadEC9e4016",
  engineer: "Admin",
  chainId: 11155111,
  proxy: false,
  abi: WAGER.abi,
  bytecode: WAGER.bytecode,
  fee: 1.0,
  description:
    "This contract is for donations only, if you send ethereum to this contract, you do so under the assumption that you will not get it back. However, depending on which odds you choose, you may get your donation back with substantial interest.",
  instructions: `Instructions on usage: This contract is set for a denomination of 0.01 ETH. You may adjust the odds within an inclusive range of 10 to 90, representing the odds of your donation being returned. The interest earned on a returned donation is inversely proportional to the odds you set, so an odds of 10 will return a donation of 1 ETH, and an odds of 90 will return a donation of 0.0111 ETH (with a 90% chance of victory.

    Since it isn't possible to provide true randomness on chain without the usage of extremely expensive chainlink VRF. Randomness is provided by the Library's own oracle network. For extra safety I have made it so, in the rare event that the oracle doesnt respond properly, or a freak error occurs, you may withdraw your funds after 5 minutes from when you made your donation`,
};

const master: SmartContract = {
  id: 8,
  name: "Master (Admin use only)",
  address: "0xE56eFe07c2a6cd7C4d41B441c3DFeb5cbc7087eF",
  engineer: "Admin",
  chainId: 10,
  proxy: false,
  abi: MASTER.abi,
  bytecode: MASTER.bytecode,
  fee: 0,
  description: "Contract description",
  instructions: "Instructions on usage: ",
};

export const contracts: SmartContract[] = [
  ethxmr,
  xmreth,
  zksnark_01,
  zksnark_05,
  zksnark_1,
  zksnark1_0,
  gambler,
  master,
];

type ContractStore = {
  contracts: SmartContract[];
  outputs: Record<string, TransactionReceipt[]> | null;
  add_output: (function_name: string, output: TransactionReceipt) => void;
  INITIALIZED_CONTRACT: Contract | null;
  SELECTED_CONTRACT: SmartContract | null;
  set_SELECTED_CONTRACT: (selected: SmartContract) => void;
  set_INITIALIZED_CONTRACT: (proxy: Contract | null) => void;
};

export const useContractStore = create<ContractStore>((set) => ({
  contracts: contracts,
  outputs: null,
  SELECTED_CONTRACT: null,
  INITIALIZED_CONTRACT: null,
  set_SELECTED_CONTRACT: (selected: SmartContract) =>
    set(() => ({ SELECTED_CONTRACT: selected })),
  set_INITIALIZED_CONTRACT: (proxy: Contract | null) =>
    set(() => ({ INITIALIZED_CONTRACT: proxy })),
  add_output: (function_name: string, output: TransactionReceipt) =>
    set((state) => {
      // Initialize outputs if null
      const currentOutputs = state.outputs || {};

      // Initialize array for this function if it doesn't exist
      const functionOutputs = currentOutputs[function_name] || [];

      // Create a new object with the updated array for this function
      return {
        outputs: {
          ...currentOutputs,
          [function_name]: [...functionOutputs, output],
        },
      };
    }),
}));
